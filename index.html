const menuScreen = document.getElementById("menuScreen");
    const gameScreen = document.getElementById("gameScreen");
    const optionsRow = document.getElementById("optionsRow");
    const dragCard = document.getElementById("dragCard");
    const dragTitle = document.getElementById("dragTitle");
    const dragImage = document.getElementById("dragImage");
    const dragSubtitle = document.getElementById("dragSubtitle");
    const symbolBar = document.getElementById("symbolBar");
    const symbolBoard = document.getElementById("symbolBoard");
    const soundToggle = document.getElementById("soundToggle");
    const backKnob = document.getElementById("backKnob");
    const backSlider = document.getElementById("backSlider");

    const MAX_SYMBOLS = 8;
    let currentChoices = 4; // Se√ßilen se√ßenek sayƒ±sƒ± (1,2,3,4,5,7)
    let currentTarget = null;
    let currentOptions = [];
    let canDrag = true;
    let correctCountForItem = 0; // her nesne i√ßin 2 kere doƒüru e≈üleme

    let earnedSymbols = 0;
    let soundEnabled = true;

    // üîä SESLER ‚Äì URL YERLERƒ∞
    // Buradaki URL'leri kendi mp3 linklerinle deƒüi≈ütir.
    const successVoices = [
      new Audio("https://ORNEK-URL/aferin.mp3"),
      new Audio("https://ORNEK-URL/bravo.mp3"),
      new Audio("https://ORNEK-URL/supersin.mp3"),
      new Audio("https://ORNEK-URL/harika-gidiyorsun.mp3")
    ];

    const countVoices = [
      new Audio("https://ORNEK-URL/1.mp3"),
      new Audio("https://ORNEK-URL/2.mp3"),
      new Audio("https://ORNEK-URL/3.mp3"),
      new Audio("https://ORNEK-URL/4.mp3"),
      new Audio("https://ORNEK-URL/5.mp3"),
      new Audio("https://ORNEK-URL/6.mp3"),
      new Audio("https://ORNEK-URL/7.mp3"),
      new Audio("https://ORNEK-URL/8.mp3")
    ];

    const allDoneVoice = new Audio("https://ORNEK-URL/tum-sembolleri-topladin.mp3");

    function playSound(audio) {
      if (!soundEnabled || !audio) return;
      audio.currentTime = 0;
      audio.play().catch(() => {});
    }

    function updateSoundToggle() {
      if (soundEnabled) {
        soundToggle.classList.remove("muted");
        soundToggle.textContent = "üîä Sesi Kapat";
      } else {
        soundToggle.classList.add("muted");
        soundToggle.textContent = "üîà Sesi A√ß";
      }
    }

    soundToggle.addEventListener("click", () => {
      soundEnabled = !soundEnabled;
      updateSoundToggle();
    });

    // ---------------------------
    // MEN√úDEN MOD SE√áƒ∞Mƒ∞
    // ---------------------------
    document.querySelectorAll(".mode-button").forEach((btn) => {
      btn.addEventListener("click", () => {
        const ch = parseInt(btn.dataset.choices, 10) || 4;
        currentChoices = ch;
        showGameScreen();
      });
    });

    function showGameScreen() {
      menuScreen.classList.add("hidden");
      gameScreen.classList.remove("hidden");
      resetSlider();
      initSymbols();
      earnedSymbols = 0;
      updateSymbols();
      setupNewRound();
    }

    function showMenuScreen() {
      gameScreen.classList.add("hidden");
      menuScreen.classList.remove("hidden");
    }

    // ---------------------------
    // MEN√úYE D√ñN SLIDER
    // ---------------------------

    let isDraggingBack = false;
    let backStartX = 0;
    let knobStartX = 0;

    function resetSlider() {
      const trackWidth = backSlider.clientWidth;
      const knobWidth = backKnob.clientWidth;
      const maxX = trackWidth - knobWidth - 8;
      backKnob.style.left = maxX + "px";
    }

    backKnob.addEventListener("pointerdown", (e) => {
      isDraggingBack = true;
      backKnob.setPointerCapture(e.pointerId);
      const rect = backKnob.getBoundingClientRect();
      backStartX = e.clientX;
      knobStartX = rect.left - backSlider.getBoundingClientRect().left;
    });

    backKnob.addEventListener("pointermove", (e) => {
      if (!isDraggingBack) return;
      const trackWidth = backSlider.clientWidth;
      const knobWidth = backKnob.clientWidth;
      const maxX = trackWidth - knobWidth - 8;
      const minX = 8;
      const dx = e.clientX - backStartX;
      let newX = knobStartX + dx;
      if (newX < minX) newX = minX;
      if (newX > maxX) newX = maxX;
      backKnob.style.left = newX + "px";
    });

    backKnob.addEventListener("pointerup", (e) => {
      if (!isDraggingBack) return;
      isDraggingBack = false;
      backKnob.releasePointerCapture(e.pointerId);
      const knobRect = backKnob.getBoundingClientRect();
      const sliderRect = backSlider.getBoundingClientRect();
      const offsetX = knobRect.left - sliderRect.left;

      // Saƒüdan sola √ßekildi, sola iyice geldiyse men√ºye d√∂n
      if (offsetX < 20) {
        showMenuScreen();
      } else {
        resetSlider();
      }
    });

    // ---------------------------
    // SEMBOLLER
    // ---------------------------
    let barStars = [];
    let boardStars = [];
    let countingMode = false;
    let countingIndex = 0;

    function initSymbols() {
      symbolBar.innerHTML = "";
      symbolBoard.innerHTML = "";
      barStars = [];
      boardStars = [];
      for (let i = 0; i < MAX_SYMBOLS; i++) {
        const barStar = document.createElement("span");
        barStar.className = "symbol-star bar-star active";
        barStar.textContent = "‚≠ê";
        symbolBar.appendChild(barStar);
        barStars.push(barStar);

        const boardStar = document.createElement("span");
        boardStar.className = "symbol-star board-star";
        boardStar.textContent = "‚≠ê";
        symbolBoard.appendChild(boardStar);
        boardStars.push(boardStar);
      }
      countingMode = false;
      countingIndex = 0;
    }

    function updateSymbols() {
      // bar tarafƒ±: kazanƒ±lmamƒ±≈ü yƒ±ldƒ±zlar
      barStars.forEach((star, index) => {
        if (index < MAX_SYMBOLS - earnedSymbols) {
          star.classList.add("active");
        } else {
          star.classList.remove("active");
        }
      });

      // board tarafƒ±: kazanƒ±lmƒ±≈ü yƒ±ldƒ±zlar
      boardStars.forEach((star, index) => {
        if (index < earnedSymbols) {
          star.classList.add("filled");
        } else {
          star.classList.remove("filled");
        }
        star.classList.remove("clickable");
      });

      if (earnedSymbols >= MAX_SYMBOLS) {
        enableCountingMode();
      }
    }

    function animateSymbolTransfer() {
      // bar merkezinden board merkezine u√ßan yƒ±ldƒ±z
      const barRect = symbolBar.getBoundingClientRect();
      const boardRect = symbolBoard.getBoundingClientRect();
      const startX = barRect.left + barRect.width / 2;
      const startY = barRect.top + barRect.height / 2;
      const endX = boardRect.left + boardRect.width / 2;
      const endY = boardRect.top + boardRect.height / 2;

      const star = document.createElement("div");
      star.className = "floating-star";
      star.textContent = "‚≠ê";
      star.style.left = startX + "px";
      star.style.top = startY + "px";
      document.body.appendChild(star);

      requestAnimationFrame(() => {
        const dx = endX - startX;
        const dy = endY - startY;
        star.style.transform = `translate(${dx}px, ${dy}px)`;
        star.style.opacity = "0";
      });

      setTimeout(() => {
        document.body.removeChild(star);
        updateSymbols();
      }, 600);
    }

    function enableCountingMode() {
      countingMode = true;
      countingIndex = 0;
      boardStars.forEach((star, index) => {
        star.classList.add("clickable");
        star.onclick = () => {
          if (!countingMode) return;
          if (index !== countingIndex) return;

          if (countingIndex < countVoices.length) {
            playSound(countVoices[countingIndex]);
          }

          boardStars[index].classList.remove("filled");
          barStars[MAX_SYMBOLS - 1 - countingIndex].classList.add("active");

          countingIndex++;
          if (countingIndex >= MAX_SYMBOLS) {
            countingMode = false;
            earnedSymbols = 0;
            playSound(allDoneVoice);
            setTimeout(() => {
              initSymbols();
            }, 700);
          }
        };
      });
    }

    // ---------------------------
    // OYUN MANTIƒûI
    // ---------------------------

    function randomItem() {
      return items[Math.floor(Math.random() * items.length)];
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function setupNewRound() {
      canDrag = true;
      dragCard.classList.remove("correct", "wrong");
      correctCountForItem = 0; // yeni nesne i√ßin sƒ±fƒ±rla

      // Hedef nesne
      currentTarget = randomItem();
      // Se√ßenekler
      setupOptionsForSameItem(true);
      // Drag kartƒ± hedef nesne
      dragTitle.textContent = currentTarget.tr;
      dragSubtitle.textContent = currentTarget.en;
      dragImage.src = `assets/${currentTarget.id}.png`;
      dragImage.alt = currentTarget.tr;

      resetDragPosition(true);
    }

    function setupOptionsForSameItem(firstTime = false) {
      const others = shuffle(
        items.filter((x) => x.id !== currentTarget.id)
      ).slice(0, Math.max(currentChoices - 1, 0));

      currentOptions = shuffle([currentTarget, ...others]).slice(
        0,
        currentChoices
      );

      optionsRow.innerHTML = "";
      currentOptions.forEach((item) => {
        const card = document.createElement("div");
        card.className = "card option-card";
        card.dataset.id = item.id;

        const titleDiv = document.createElement("div");
        titleDiv.className = "card-title";
        titleDiv.textContent = item.tr;

        const imageDiv = document.createElement("div");
        imageDiv.className = "card-image";
        const img = document.createElement("img");
        img.src = `assets/${item.id}.png`;
        img.alt = item.tr;
        imageDiv.appendChild(img);

        const subDiv = document.createElement("div");
        subDiv.className = "card-subtitle";
        subDiv.textContent = item.en;

        card.appendChild(titleDiv);
        card.appendChild(imageDiv);
        card.appendChild(subDiv);

        optionsRow.appendChild(card);
      });

      if (!firstTime) {
        resetDragPosition(true);
        dragCard.classList.remove("correct", "wrong");
      }
    }

    // ---------------------------
    // DRAG & DROP
    // ---------------------------

    let dragActive = false;
    let pointerId = null;
    let dragStartX = 0;
    let dragStartY = 0;
    let baseX = 0;
    let baseY = 0;

    function getCurrentTransform(elem) {
      const style = window.getComputedStyle(elem);
      const matrix = new DOMMatrixReadOnly(style.transform);
      return { x: matrix.m41, y: matrix.m42 };
    }

    function resetDragPosition(immediate = false) {
      const t = immediate ? "transform 0s" : "transform 0.25s ease";
      dragCard.style.transition = t;
      dragCard.style.transform = "translate(0px, 0px)";
    }

    dragCard.addEventListener("pointerdown", (e) => {
      if (!canDrag) return;
      dragActive = true;
      pointerId = e.pointerId;
      dragCard.setPointerCapture(pointerId);
      const current = getCurrentTransform(dragCard);
      baseX = current.x;
      baseY = current.y;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragCard.style.transition = "none";
    });

    dragCard.addEventListener("pointermove", (e) => {
      if (!dragActive || e.pointerId !== pointerId) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      dragCard.style.transform = `translate(${baseX + dx}px, ${baseY + dy}px)`;
    });

    dragCard.addEventListener("pointerup", (e) => {
      if (!dragActive || e.pointerId !== pointerId) return;
      dragActive = false;
      dragCard.releasePointerCapture(pointerId);
      handleDrop();
    });

    function handleDrop() {
      const dragRect = dragCard.getBoundingClientRect();
      const optionCards = Array.from(
        document.querySelectorAll(".option-card")
      );
      let hitCard = null;
      let hitItem = null;

      for (let i = 0; i < optionCards.length; i++) {
        const card = optionCards[i];
        const rect = card.getBoundingClientRect();
        const overlap =
          dragRect.right > rect.left &&
          dragRect.left < rect.right &&
          dragRect.bottom > rect.top &&
          dragRect.top < rect.bottom;
        if (overlap) {
          hitCard = card;
          hitItem = currentOptions[i];
          break;
        }
      }

      if (!hitCard || !hitItem) {
        showWrongFeedback();
        return;
      }

      if (hitItem.id === currentTarget.id) {
        showCorrectFeedback(hitCard);
      } else {
        showWrongFeedback();
      }
    }

    function showWrongFeedback() {
      dragCard.classList.add("wrong");
      canDrag = false;
      setTimeout(() => {
        dragCard.classList.remove("wrong");
        resetDragPosition(false);
        setTimeout(() => {
          canDrag = true;
        }, 260);
      }, 260);
    }

    function showCorrectFeedback(targetCard) {
      canDrag = false;
      dragCard.classList.add("correct");
      targetCard.classList.add("correct");

      // Drag kartƒ± hedef karta doƒüru yumu≈üak ≈üekilde kaydƒ±r
      const dragRect = dragCard.getBoundingClientRect();
      const targetRect = targetCard.getBoundingClientRect();
      const dx =
        targetRect.left +
        targetRect.width / 2 -
        (dragRect.left + dragRect.width / 2);
      const dy =
        targetRect.top +
        targetRect.height / 2 -
        (dragRect.top + dragRect.height / 2);

      dragCard.style.transition = "transform 0.35s ease";
      dragCard.style.transform = `translate(${dx}px, ${dy}px)`;

      // Sembol kazanma
      if (earnedSymbols < MAX_SYMBOLS) {
        earnedSymbols++;
        animateSymbolTransfer();
        // Random aferin sesi
        const voice =
          successVoices[
            Math.floor(Math.random() * successVoices.length)
          ];
        playSound(voice);
      }

      setTimeout(() => {
        targetCard.classList.remove("correct");
        dragCard.classList.remove("correct");
        resetDragPosition(true);

        // Aynƒ± nesne 2 kere doƒüru e≈ülensin
        correctCountForItem++;
        if (correctCountForItem < 2) {
          // Aynƒ± nesne, se√ßenekler karƒ±≈üsƒ±n
          setupOptionsForSameItem(false);
          canDrag = true;
        } else {
          // Yeni nesneye ge√ß
          setTimeout(() => {
            setupNewRound();
          }, 80);
        }
      }, 650);
    }

    // ---------------------------
    // BA≈ûLANGI√á
    // ---------------------------

    updateSoundToggle();
    // Ba≈üta men√º g√∂r√ºnecek, oyuna girince setupNewRound √ßaƒürƒ±lacak
  </script>
</body>
</html>
